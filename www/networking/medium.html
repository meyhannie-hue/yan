<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ethernet Wiring Game - Crossover (Medium)</title>
  <link rel="stylesheet" href="style/medium.css" />
</head>
<body>
  <button class="back-btn" onclick="window.history.back()">‚üµ Back</button>
  <h1>Ethernet Wiring Game - Crossover (Medium)</h1>
  <div class="timer">‚è≥ Time left: <span id="countdown">1:00</span></div>

  <div class="game">
    <canvas id="lineCanvas" width="1920" height="1080"></canvas>
    <div class="column" id="pinColumn"></div>
    <div class="column" id="wireColumn"></div>
  </div>

  <button class="submit-btn" onclick="checkWiring()">Submit</button>

  <script>
    const canvas = document.getElementById('lineCanvas');
    const ctx = canvas.getContext('2d');
    let startWire = null;
    let connections = [];
    let timeLeft = 60;
    let timerStarted = false;
    let timer;
    const countdownEl = document.getElementById('countdown');

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return `${m}:${s < 10 ? '0' : ''}${s}`;
    }

    function startTimer() {
      if (timerStarted) return;
      timerStarted = true;
      countdownEl.textContent = formatTime(timeLeft);
      timer = setInterval(() => {
        timeLeft--;
        countdownEl.textContent = formatTime(timeLeft);
        if (timeLeft <= 0) {
          clearInterval(timer);
          alert("‚è∞ Time's up! Try again.");
          location.reload();
        }
      }, 1000);
    }

    function drawConnections() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const rect = canvas.getBoundingClientRect();
      connections.forEach(conn => {
        const pinDot = document.querySelector(`.slot[data-pin="${conn.pin}"] .pin-dot`).getBoundingClientRect();
        const wireDot = conn.wire.querySelector('.pin-dot').getBoundingClientRect();
        const x1 = wireDot.left + wireDot.width / 2 - rect.left;
        const y1 = wireDot.top + wireDot.height / 2 - rect.top;
        const x2 = pinDot.left + pinDot.width / 2 - rect.left;
        const y2 = pinDot.top + pinDot.height / 2 - rect.top;

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineWidth = 4;

        if (conn.color.includes('-')) {
          const [c1, c2] = conn.color.split('-');
          const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
          gradient.addColorStop(0, c1.toLowerCase());
          gradient.addColorStop(1, c2.toLowerCase());
          ctx.strokeStyle = gradient;
        } else {
          ctx.strokeStyle = conn.color.toLowerCase();
        }
        ctx.stroke();
      });
    }

    document.addEventListener("DOMContentLoaded", () => {
      for (let i = 1; i <= 8; i++) {
        const slot = document.createElement("div");
        slot.className = "slot";
        slot.dataset.pin = i;
        slot.innerHTML = `Pin ${i} <span class="pin-dot"></span>`;
        document.getElementById("pinColumn").appendChild(slot);
      }

      const wireData = {
        "White-Green": "linear-gradient(to right, white 50%, green 50%)",
        "Green": "green",
        "White-Orange": "linear-gradient(to right, white 50%, orange 50%)",
        "Blue": "blue",
        "White-Blue": "linear-gradient(to right, white 50%, blue 50%)",
        "Orange": "orange",
        "White-Brown": "linear-gradient(to right, white 50%, brown 50%)",
        "Brown": "brown"
      };

      const shuffled = Object.keys(wireData).sort(() => Math.random() - 0.5);
      shuffled.forEach(color => {
        const div = document.createElement("div");
        div.className = "wire";
        div.draggable = true;
        div.dataset.color = color;
        div.style.background = wireData[color];
        div.innerHTML = `<span class="pin-dot"></span> ${color}`;
        document.getElementById("wireColumn").appendChild(div);

        div.addEventListener("dragstart", () => {
          startWire = div;
          startTimer();
        });
        div.addEventListener("mousedown", startTimer);
        div.addEventListener("touchstart", startTimer);
      });

      document.querySelectorAll('.slot').forEach(slot => {
        slot.addEventListener('dragover', e => e.preventDefault());
        slot.addEventListener('drop', () => {
          const pin = slot.getAttribute('data-pin');
          const color = startWire.getAttribute('data-color');
          connections = connections.filter(c => c.pin !== pin && c.color !== color);
          connections.push({ pin, color, wire: startWire });
          drawConnections();
        });
      });
    });

   function checkWiring() {
    const correct = [
        'White-Green', 'Green', 'White-Orange', 'Blue',
        'White-Blue', 'Orange', 'White-Brown', 'Brown'
    ];

    if (connections.length < 8) {
        alert("‚ö†Ô∏è Incomplete: Please connect all wires.");
        return;
    }

    let totalCorrect = 0;
    connections.forEach((c, i) => {
        if (c.color === correct[i]) totalCorrect++;
    });

    if (totalCorrect === 8) {
        alert("‚úÖ Perfect wiring!");

        const username = sessionStorage.getItem("playerName");
        if (!username) {
            alert("‚ö†Ô∏è No username found. Points cannot be awarded.");
            return;
        }

        // Tell backend: medium perfect achieved
        fetch("http://localhost:3000/api/networking-medium-perfect", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ username })
        })
        .then(res => res.json())
        .then(data => {
            alert(data.message || "üèÜ 3040 points awarded!");
            window.location.href = "../levels/networkinglevels.html";
        })
        .catch(err => {
            console.error("Error awarding points:", err);
            alert("‚ùå Could not award points.");
        });

        return; // ‚úÖ stop after awarding
    } else {
        alert(`‚ùå You got ${totalCorrect}/8 correct. Try again!`);
    }
} // ‚úÖ same as easy level
 </script>
</body>
</html>
